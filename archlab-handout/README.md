# archlab
emmm怎么说呢...这次的lab可以说是目前我做过的lab中最难的了  
（虽然在运行benchmark.pl之前我的想法完全是反过来的）  
可以说的点还是蛮多的，当然不是说partA和partB  
这两个依然是最简单的，内心评价不变，毕竟是做过一遍的东西  
  
先来讲一下自己的心路历程  
这个东西估计实现iaddq就差不多了 => 好简单，跑下benchmark吧，诶我怎么零分??? => emmm循环展开，好像有印象在以前的gcc出来的汇编里见过类似的东西 => 哇，我有分了，虽然不到一半 => 哇，我怎么把load/use hazard忘了...40多分了! => 哇，dalao的做法好妙 => 难道不删xorq %rax, %rax 就不能满分了么 => 还是去修改hcl吧 => 终于...
差不多就这样吧，自己写完展开之后发现分数没有一半就去搜dalao的做法，然后在大量的尝试和修改之后，终于达到了59.8分...随后在各种意义不大的尝试之后，最终还是去修改hcl了，然后成功60...  
emmm个人来说拒绝删掉xorq %rax, %rax的语句的做法，实际运行时rax的值是任意的，初始化是必须的  
  
## 下面开始讲自己注意到的优化点:  
  
### 首先是不动hcl的情况下:  
1.第一次计算长度是否大于等于9时，条件跳转到余数判断部分，这样会使得0~8的周期数变少，在更长长度的时钟数已经比较短的情况下，短长度的时钟数的缩小对于结果的优化效果显然更高  
2.树内跳转基本上遵循着单叶的情况下小余数优先级大于大余数，多叶的情况下不定，但是整体还是小余数优先级大于大余数，但是当大余数子树和小余数子树的叶个数差比较大时有可能反过来  
3.余数内使用比自己高一位的余数的条件跳转避免use/load hazard，这使得我们必须在条件码满足le的情况下进入剩余处理阶段，当然这也使得余数8不能回避use/load hazard的气泡  
4.借助上一条，每次进入余数我们会有一条必然执行的条件跳转，借助这一点，我们可以预执行本应该rmmovq语句把进入剩余处理阶段的跳转点设为那次必然执行的条件跳转的目的地，同时可以去掉必须在条件码满足le的情况下进入剩余处理阶段的限制，这是9位的充裕空间才能做到的事情，借助这一点，我也让分数达到了59.8  
  
### 修改hcl的情况下：  
因为mrmovq直到memory阶段才会使用valA的值，所以修改hcl避免那个use/load hazard(这也是在homework中做过的事情)，在充分利用树跳转的情况下，很轻易就把我们的代码修改为7.48版本  
  
差不多就这么多了，做完的时候说实话成就感有限，更多的是解脱感...终于做完了第四章相关，可以继续推csapp进度了QAQ  
  
